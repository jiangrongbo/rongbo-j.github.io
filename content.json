[{"title":"HashSet 底层分析","date":"2018-04-30T05:53:47.000Z","path":"2018/04/30/HashSet/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"ReentrantLock 实现原理","date":"2018-04-29T22:42:32.000Z","path":"2018/04/30/ReentrantLock/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"HashMap 底层分析","date":"2018-04-26T11:00:44.000Z","path":"2018/04/26/HashMap/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"深入理解线程通信","date":"2018-04-24T17:15:54.000Z","path":"2018/04/25/thread-communication/","tags":[{"name":"Thread","slug":"Thread","permalink":"http://blog4java.com/tags/Thread/"}]},{"title":"Java 多线程常见问题","date":"2018-04-24T15:03:10.000Z","path":"2018/04/24/Thread-common-problem/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"一致 Hash 算法","date":"2018-04-24T02:47:13.000Z","path":"2018/04/24/Consistent-Hash/","tags":[{"name":"分布式","slug":"分布式","permalink":"http://blog4java.com/tags/分布式/"}]},{"title":"设计一个秒杀系统","date":"2018-04-17T02:01:21.000Z","path":"2018/04/17/Spike/","tags":[{"name":"Spike","slug":"Spike","permalink":"http://blog4java.com/tags/Spike/"}]},{"title":"Java 多线程三大核心","date":"2018-04-16T01:13:33.000Z","path":"2018/04/16/Threadcore/","tags":[{"name":"Thread","slug":"Thread","permalink":"http://blog4java.com/tags/Thread/"}]},{"title":"树形结构的处理——组合模式（三）","date":"2018-03-31T20:37:08.000Z","path":"2018/04/01/design_pattern_87/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"测试文章","date":"2018-03-29T08:16:09.000Z","path":"2018/03/29/test/","tags":[{"name":"test","slug":"test","permalink":"http://blog4java.com/tags/test/"}]},{"title":"工厂三兄弟之工厂方法模式（二）","date":"2018-03-28T17:54:09.000Z","path":"2018/03/29/design_pattern_58/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂三兄弟之抽象工厂模式（四）","date":"2018-03-28T17:11:26.000Z","path":"2018/03/29/design_pattern_64/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"多人联机射击游戏中的设计模式应用（一）","date":"2018-03-28T15:55:21.000Z","path":"2018/03/28/design_pattern_39/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"多人联机射击游戏中的设计模式应用（二）","date":"2018-03-27T20:38:05.000Z","path":"2018/03/28/design_pattern_40/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"六个创建型模式","date":"2018-03-26T13:56:24.000Z","path":"2018/03/26/design_pattern_12/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"Hello World","date":"2018-03-26T06:14:00.000Z","path":"2018/03/26/hello-world/","tags":[]},{"title":"垃圾回收","date":"2018-03-25T19:49:03.000Z","path":"2018/03/26/GarbageCollection/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"OOM 分析","date":"2018-03-25T05:18:38.000Z","path":"2018/03/25/OOM-analysis/","tags":[{"name":"OOM-analysis","slug":"OOM-analysis","permalink":"http://blog4java.com/tags/OOM-analysis/"}]},{"title":"复杂对象的组装与创建——建造者模式（二）","date":"2018-03-21T15:46:29.000Z","path":"2018/03/21/design_pattern_36/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"数据库水平垂直拆分","date":"2018-03-21T07:33:01.000Z","path":"2018/03/21/DB-split/","tags":[{"name":"数据库","slug":"数据库","permalink":"http://blog4java.com/tags/数据库/"}]},{"title":"处理对象的多种状态及其相互转换——状态模式（五）","date":"2018-03-19T05:57:48.000Z","path":"2018/03/19/design_pattern_30/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"算法的封装与切换——策略模式（三）","date":"2018-03-18T22:34:34.000Z","path":"2018/03/19/design_pattern_108/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"面向对象设计原则之单一职责原则","date":"2018-03-17T15:04:19.000Z","path":"2018/03/17/design_pattern_157/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"MySQL 索引原理","date":"2018-03-15T08:22:10.000Z","path":"2018/03/15/MySQL-Index/","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog4java.com/tags/MySQL/"}]},{"title":"分布式缓存设计","date":"2018-03-13T05:56:35.000Z","path":"2018/03/13/Cache-design/","tags":[{"name":"cache","slug":"cache","permalink":"http://blog4java.com/tags/cache/"}]},{"title":"请求的链式处理——职责链模式（一）","date":"2018-03-11T01:03:34.000Z","path":"2018/03/11/design_pattern_143/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"ArrayList/Vector 的底层分析","date":"2018-03-09T14:16:43.000Z","path":"2018/03/09/ArrayList/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"不兼容结构的协调——适配器模式（二）","date":"2018-03-07T09:55:46.000Z","path":"2018/03/07/design_pattern_4/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"Java 运行时的内存划分","date":"2018-03-07T05:09:35.000Z","path":"2018/03/07/MemoryAllocation/","tags":[{"name":"JVM","slug":"JVM","permalink":"http://blog4java.com/tags/JVM/"}]},{"title":"对象间的联动——观察者模式（六）","date":"2018-03-06T20:54:27.000Z","path":"2018/03/07/design_pattern_54/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"确保对象的唯一性——单例模式 （四）","date":"2018-03-06T01:47:49.000Z","path":"2018/03/06/design_pattern_104/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"自定义语言的实现——解释器模式（二）","date":"2018-03-04T12:24:30.000Z","path":"2018/03/04/design_pattern_115/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"从招式与内功谈起——设计模式概述（三）","date":"2018-03-03T14:54:21.000Z","path":"2018/03/03/design_pattern_9/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"ConcurrentHashMap 实现原理","date":"2018-03-02T00:52:25.000Z","path":"2018/03/02/ConcurrentHashMap/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"线程池原理分析","date":"2018-03-01T09:38:51.000Z","path":"2018/03/01/ThreadPoolExecutor/","tags":[{"name":"Thread","slug":"Thread","permalink":"http://blog4java.com/tags/Thread/"}]},{"title":"不兼容结构的协调——适配器模式（三）","date":"2018-02-27T04:13:11.000Z","path":"2018/02/27/design_pattern_3/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"你应该知道的 volatile 关键字","date":"2018-02-26T03:29:08.000Z","path":"2018/02/26/volatile/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"限流算法","date":"2018-02-24T14:22:16.000Z","path":"2018/02/24/Limiting/","tags":[{"name":"算法","slug":"算法","permalink":"http://blog4java.com/tags/算法/"}]},{"title":"扩展系统功能——装饰模式（一）","date":"2018-02-23T01:19:15.000Z","path":"2018/02/23/design_pattern_71/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂三兄弟之简单工厂模式（三）","date":"2018-02-21T11:14:21.000Z","path":"2018/02/21/design_pattern_66/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"不兼容结构的协调——适配器模式（一）","date":"2018-02-21T05:53:14.000Z","path":"2018/02/21/design_pattern_2/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式与足球（四）","date":"2018-02-19T00:44:18.000Z","path":"2018/02/19/design_pattern_125/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"Synchronized 关键字原理","date":"2018-02-17T04:54:17.000Z","path":"2018/02/17/Synchronize/","tags":[{"name":"并发","slug":"并发","permalink":"http://blog4java.com/tags/并发/"}]},{"title":"Spring AOP 实现原理","date":"2018-02-15T12:52:45.000Z","path":"2018/02/15/SpringAOP/","tags":[{"name":"AOP","slug":"AOP","permalink":"http://blog4java.com/tags/AOP/"}]},{"title":"工厂三兄弟之抽象工厂模式（五）","date":"2018-02-11T15:52:43.000Z","path":"2018/02/11/design_pattern_63/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"算法的封装与切换——策略模式（二）","date":"2018-02-10T19:10:59.000Z","path":"2018/02/11/design_pattern_109/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"Spring Bean 生命周期","date":"2018-02-09T18:14:14.000Z","path":"2018/02/10/spring-bean-lifecycle/","tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog4java.com/tags/Spring/"}]},{"title":"多人联机射击游戏","date":"2018-02-07T12:24:15.000Z","path":"2018/02/07/design_pattern_38/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"分布式 ID 生成器","date":"2018-02-07T08:57:13.000Z","path":"2018/02/07/ID-generator/","tags":[{"name":"分布式","slug":"分布式","permalink":"http://blog4java.com/tags/分布式/"}]},{"title":"实现对象的复用——享元模式（一）","date":"2018-02-07T08:13:55.000Z","path":"2018/02/07/design_pattern_41/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"SQL 优化","date":"2018-02-02T22:42:00.000Z","path":"2018/02/03/SQL-optimization/","tags":[{"name":"SQL优化","slug":"SQL优化","permalink":"http://blog4java.com/tags/SQL优化/"}]},{"title":"对象的创建与内存分配","date":"2018-02-02T17:31:39.000Z","path":"2018/02/03/newObject/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"TCP/IP 协议","date":"2018-02-02T09:33:39.000Z","path":"2018/02/02/IP/","tags":[{"name":"网络","slug":"网络","permalink":"http://blog4java.com/tags/网络/"}]},{"title":"请求发送者与接收者解耦——命令模式（二）","date":"2018-01-31T14:44:02.000Z","path":"2018/01/31/design_pattern_139/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"自定义语言的实现——解释器模式（三）","date":"2018-01-26T15:00:47.000Z","path":"2018/01/26/design_pattern_114/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"LinkedList 底层分析","date":"2018-01-23T13:28:18.000Z","path":"2018/01/23/LinkedList/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"LinkedHashMap 底层分析","date":"2018-01-21T12:19:36.000Z","path":"2018/01/21/LinkedHashMap/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"工厂三兄弟之简单工厂模式（二）","date":"2018-01-19T01:56:35.000Z","path":"2018/01/19/design_pattern_67/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"职责链模式-Chain of Responsibility Pattern","date":"2018-01-17T19:47:32.000Z","path":"2018/01/18/design_pattern_112/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式综合实例分析之数据库同步系统（一）","date":"2018-01-13T08:03:15.000Z","path":"2018/01/13/design_pattern_131/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"对锁的一些认知 有哪些锁","date":"2018-01-12T06:54:18.000Z","path":"2018/01/12/Java-lock/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"处理对象的多种状态及其相互转换——状态模式（六）","date":"2018-01-11T13:44:15.000Z","path":"2018/01/11/design_pattern_31/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"深入浅出外观模式（一）","date":"2018-01-10T13:40:21.000Z","path":"2018/01/10/design_pattern_96/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"类加载机制","date":"2018-01-08T08:22:44.000Z","path":"2018/01/08/ClassLoad/","tags":[{"name":"Java","slug":"Java","permalink":"http://blog4java.com/tags/Java/"}]},{"title":"观察者模式-Observer Pattern","date":"2018-01-07T13:03:50.000Z","path":"2018/01/07/design_pattern_120/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"协调多个对象之间的交互——中介者模式（一）","date":"2018-01-07T11:10:28.000Z","path":"2018/01/07/design_pattern_14/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"确保对象的唯一性——单例模式 （五）","date":"2018-01-05T23:56:24.000Z","path":"2018/01/06/design_pattern_103/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"命令模式-Command Pattern","date":"2017-12-31T02:31:27.000Z","path":"2017/12/31/design_pattern_21/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"树形结构的处理——组合模式（一）","date":"2017-12-28T06:19:54.000Z","path":"2017/12/28/design_pattern_86/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"扩展系统功能——装饰模式（二）","date":"2017-12-27T01:01:29.000Z","path":"2017/12/27/design_pattern_73/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式综合实例分析之数据库同步系统（二）","date":"2017-12-26T18:42:02.000Z","path":"2017/12/27/design_pattern_133/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"撤销功能的实现——备忘录模式（二）","date":"2017-12-26T09:55:36.000Z","path":"2017/12/26/design_pattern_78/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"撤销功能的实现——备忘录模式（三）","date":"2017-12-25T12:43:05.000Z","path":"2017/12/25/design_pattern_77/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"遍历聚合对象中的元素——迭代器模式（三）","date":"2017-12-23T03:56:18.000Z","path":"2017/12/23/design_pattern_150/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"请求的链式处理——职责链模式（三）","date":"2017-12-22T18:17:56.000Z","path":"2017/12/23/design_pattern_144/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"操作复杂对象结构——访问者模式（一）","date":"2017-12-21T19:26:01.000Z","path":"2017/12/22/design_pattern_81/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"实现对象的复用——享元模式（三）","date":"2017-12-18T09:08:29.000Z","path":"2017/12/18/design_pattern_42/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"请求发送者与接收者解耦——命令模式（四）","date":"2017-12-12T01:52:48.000Z","path":"2017/12/12/design_pattern_142/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"自定义语言的实现——解释器模式（四）","date":"2017-12-09T23:02:25.000Z","path":"2017/12/10/design_pattern_118/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"代理模式-Proxy Pattern","date":"2017-12-09T05:33:49.000Z","path":"2017/12/09/design_pattern_11/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"遍历聚合对象中的元素——迭代器模式（二）","date":"2017-12-02T07:56:59.000Z","path":"2017/12/02/design_pattern_151/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"适配器模式-Adapter Pattern","date":"2017-12-01T14:31:49.000Z","path":"2017/12/01/design_pattern_148/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"对象间的联动——观察者模式（三）","date":"2017-11-30T02:46:26.000Z","path":"2017/11/30/design_pattern_51/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"对象的克隆——原型模式（一）","date":"2017-11-29T06:11:16.000Z","path":"2017/11/29/design_pattern_46/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"树形结构的处理——组合模式（二）","date":"2017-11-23T17:47:52.000Z","path":"2017/11/24/design_pattern_88/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"迭代器模式-Iterator Pattern","date":"2017-11-23T11:10:54.000Z","path":"2017/11/23/design_pattern_147/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"数据库同步系统","date":"2017-11-18T06:28:11.000Z","path":"2017/11/18/design_pattern_85/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂三兄弟之工厂方法模式（三）","date":"2017-11-17T15:37:52.000Z","path":"2017/11/17/design_pattern_57/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"外观模式-Facade Pattern","date":"2017-11-16T20:08:56.000Z","path":"2017/11/17/design_pattern_37/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂三兄弟之抽象工厂模式（二）","date":"2017-11-16T13:44:16.000Z","path":"2017/11/16/design_pattern_62/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂三兄弟之抽象工厂模式（一）","date":"2017-11-11T13:52:34.000Z","path":"2017/11/11/design_pattern_60/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"模板方法模式深度解析（一）","date":"2017-11-08T23:37:41.000Z","path":"2017/11/09/design_pattern_93/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"模板方法模式-Template Method Pattern","date":"2017-11-06T02:12:23.000Z","path":"2017/11/06/design_pattern_92/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"面向对象设计原则之开闭原则","date":"2017-10-30T07:24:35.000Z","path":"2017/10/30/design_pattern_159/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"自定义语言的实现——解释器模式（一）","date":"2017-10-27T22:43:37.000Z","path":"2017/10/28/design_pattern_113/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"操作复杂对象结构——访问者模式（二）","date":"2017-10-21T21:45:24.000Z","path":"2017/10/22/design_pattern_83/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"模板方法模式深度解析（二）","date":"2017-10-21T08:53:27.000Z","path":"2017/10/21/design_pattern_95/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"对象间的联动——观察者模式（二）","date":"2017-10-19T07:16:37.000Z","path":"2017/10/19/design_pattern_52/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"算法的封装与切换——策略模式（四）","date":"2017-10-19T01:16:58.000Z","path":"2017/10/19/design_pattern_110/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"算法的封装与切换——策略模式（一）","date":"2017-10-18T10:38:01.000Z","path":"2017/10/18/design_pattern_107/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"处理对象的多种状态及其相互转换——状态模式（四）","date":"2017-10-17T13:11:33.000Z","path":"2017/10/17/design_pattern_32/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"请求的链式处理——职责链模式（四）","date":"2017-10-13T22:28:16.000Z","path":"2017/10/14/design_pattern_146/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"确保对象的唯一性——单例模式 （二）","date":"2017-10-09T07:16:40.000Z","path":"2017/10/09/design_pattern_102/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"复杂对象的组装与创建——建造者模式（一）","date":"2017-10-03T23:31:30.000Z","path":"2017/10/04/design_pattern_34/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"对象的克隆——原型模式（三）","date":"2017-10-02T09:26:16.000Z","path":"2017/10/02/design_pattern_47/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"实现对象的复用——享元模式（五）","date":"2017-09-30T07:57:25.000Z","path":"2017/09/30/design_pattern_44/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂方法模式-Factory Method Pattern","date":"2017-09-29T16:14:05.000Z","path":"2017/09/30/design_pattern_69/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"原型模式-Prototype Pattern","date":"2017-09-27T20:44:01.000Z","path":"2017/09/28/design_pattern_20/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"简单工厂模式-Simple Factory Pattern","date":"2017-09-25T23:42:06.000Z","path":"2017/09/26/design_pattern_106/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"树形结构的处理——组合模式（四）","date":"2017-09-24T10:45:32.000Z","path":"2017/09/24/design_pattern_90/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"请求发送者与接收者解耦——命令模式（五）","date":"2017-09-21T19:53:05.000Z","path":"2017/09/22/design_pattern_140/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"操作复杂对象结构——访问者模式（三）","date":"2017-09-21T12:50:42.000Z","path":"2017/09/21/design_pattern_82/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"处理对象的多种状态及其相互转换——状态模式（三）","date":"2017-09-20T04:09:51.000Z","path":"2017/09/20/design_pattern_28/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"从招式与内功谈起——设计模式概述（二）","date":"2017-09-17T16:42:44.000Z","path":"2017/09/18/design_pattern_10/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"请求发送者与接收者解耦——命令模式（三）","date":"2017-09-16T04:32:23.000Z","path":"2017/09/16/design_pattern_138/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"策略模式-Strategy Pattern","date":"2017-09-12T23:44:03.000Z","path":"2017/09/13/design_pattern_105/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"解释器模式-Interpreter Pattern","date":"2017-09-10T08:35:50.000Z","path":"2017/09/10/design_pattern_121/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"面向对象设计原则之迪米特法则","date":"2017-09-05T14:28:15.000Z","path":"2017/09/05/design_pattern_161/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂三兄弟之简单工厂模式（四）","date":"2017-09-03T04:50:53.000Z","path":"2017/09/03/design_pattern_68/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"遍历聚合对象中的元素——迭代器模式（六）","date":"2017-09-02T08:54:51.000Z","path":"2017/09/02/design_pattern_153/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"请求的链式处理——职责链模式（二）","date":"2017-08-31T23:32:14.000Z","path":"2017/09/01/design_pattern_145/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式与足球（一）","date":"2017-08-31T11:13:40.000Z","path":"2017/08/31/design_pattern_122/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"处理多维度变化——桥接模式（三）","date":"2017-08-28T10:13:09.000Z","path":"2017/08/28/design_pattern_24/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"基础知识","date":"2017-08-23T22:50:23.000Z","path":"2017/08/24/design_pattern_22/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"抽象工厂模式-Abstract  Factory Pattern","date":"2017-08-22T17:13:29.000Z","path":"2017/08/23/design_pattern_75/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"复杂对象的组装与创建——建造者模式（三）","date":"2017-08-22T01:24:15.000Z","path":"2017/08/22/design_pattern_35/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"遍历聚合对象中的元素——迭代器模式（四）","date":"2017-08-21T07:41:11.000Z","path":"2017/08/21/design_pattern_154/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"对象间的联动——观察者模式（一）","date":"2017-08-20T04:57:07.000Z","path":"2017/08/20/design_pattern_50/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"实现对象的复用——享元模式（四）","date":"2017-08-19T20:14:50.000Z","path":"2017/08/20/design_pattern_45/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式综合实例分析之数据库同步系统（三）","date":"2017-08-15T03:27:53.000Z","path":"2017/08/15/design_pattern_132/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"中介者模式-Mediator Pattern","date":"2017-08-12T20:04:53.000Z","path":"2017/08/13/design_pattern_6/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"撤销功能的实现——备忘录模式（一）","date":"2017-08-11T05:30:08.000Z","path":"2017/08/11/design_pattern_76/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"自定义语言的实现——解释器模式（六）","date":"2017-08-10T10:18:29.000Z","path":"2017/08/10/design_pattern_117/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"组合模式-Composite Pattern","date":"2017-08-05T08:41:01.000Z","path":"2017/08/05/design_pattern_111/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"对象间的联动——观察者模式（四）","date":"2017-08-03T06:37:08.000Z","path":"2017/08/03/design_pattern_55/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"协调多个对象之间的交互——中介者模式（四）","date":"2017-08-01T23:05:48.000Z","path":"2017/08/02/design_pattern_18/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"确保对象的唯一性——单例模式 （三）","date":"2017-08-01T06:53:27.000Z","path":"2017/08/01/design_pattern_101/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"撤销功能的实现——备忘录模式（五）","date":"2017-08-01T00:09:48.000Z","path":"2017/08/01/design_pattern_79/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式概述","date":"2017-07-31T08:17:54.000Z","path":"2017/07/31/design_pattern_130/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"面向对象设计原则之接口隔离原则","date":"2017-07-25T14:38:47.000Z","path":"2017/07/25/design_pattern_160/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"单例模式-Singleton Pattern","date":"2017-07-22T15:44:00.000Z","path":"2017/07/22/design_pattern_19/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"面向对象设计原则之依赖倒转原则","date":"2017-07-22T10:05:30.000Z","path":"2017/07/22/design_pattern_156/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"协调多个对象之间的交互——中介者模式（五）","date":"2017-07-14T05:00:23.000Z","path":"2017/07/14/design_pattern_17/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"请求发送者与接收者解耦——命令模式（一）","date":"2017-07-13T00:34:31.000Z","path":"2017/07/13/design_pattern_137/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"处理多维度变化——桥接模式（一）","date":"2017-07-09T04:09:05.000Z","path":"2017/07/09/design_pattern_23/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"自定义语言的实现——解释器模式（五）","date":"2017-07-08T01:09:28.000Z","path":"2017/07/08/design_pattern_116/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"请求发送者与接收者解耦——命令模式（六）","date":"2017-07-06T08:42:51.000Z","path":"2017/07/06/design_pattern_141/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"遍历聚合对象中的元素——迭代器模式（五）","date":"2017-07-06T06:51:10.000Z","path":"2017/07/06/design_pattern_152/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"协调多个对象之间的交互——中介者模式（三）","date":"2017-07-06T02:03:25.000Z","path":"2017/07/06/design_pattern_15/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"对象的克隆——原型模式（四）","date":"2017-07-02T13:57:05.000Z","path":"2017/07/02/design_pattern_49/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"处理多维度变化——桥接模式（二）","date":"2017-06-29T22:26:53.000Z","path":"2017/06/30/design_pattern_25/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"树形结构的处理——组合模式（五）","date":"2017-06-28T00:02:44.000Z","path":"2017/06/28/design_pattern_89/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"十一个行为型模式","date":"2017-06-27T05:20:32.000Z","path":"2017/06/27/design_pattern_13/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"装饰模式-Decorator Pattern","date":"2017-06-26T04:16:22.000Z","path":"2017/06/26/design_pattern_119/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"面向对象设计原则之合成复用原则","date":"2017-06-25T03:28:54.000Z","path":"2017/06/25/design_pattern_158/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"不兼容结构的协调——适配器模式（四）","date":"2017-06-24T20:50:28.000Z","path":"2017/06/25/design_pattern_5/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"七个结构型模式","date":"2017-06-22T11:34:18.000Z","path":"2017/06/22/design_pattern_1/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式之代理模式（一）","date":"2017-06-20T22:16:55.000Z","path":"2017/06/21/design_pattern_126/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂三兄弟之抽象工厂模式（三）","date":"2017-06-20T14:35:51.000Z","path":"2017/06/20/design_pattern_61/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"扩展系统功能——装饰模式（四）","date":"2017-06-17T16:19:39.000Z","path":"2017/06/18/design_pattern_74/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"遍历聚合对象中的元素——迭代器模式（一）","date":"2017-06-16T19:44:12.000Z","path":"2017/06/17/design_pattern_149/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"状态模式-State Pattern","date":"2017-06-12T08:24:08.000Z","path":"2017/06/12/design_pattern_99/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"确保对象的唯一性——单例模式 （一）","date":"2017-06-11T13:50:50.000Z","path":"2017/06/11/design_pattern_100/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"协调多个对象之间的交互——中介者模式（二）","date":"2017-06-11T03:16:21.000Z","path":"2017/06/11/design_pattern_16/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"操作复杂对象结构——访问者模式（四）","date":"2017-06-09T18:25:13.000Z","path":"2017/06/10/design_pattern_84/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂三兄弟之工厂方法模式（四）","date":"2017-06-07T20:44:38.000Z","path":"2017/06/08/design_pattern_59/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"面向对象设计原则","date":"2017-06-03T05:22:54.000Z","path":"2017/06/03/design_pattern_155/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"处理对象的多种状态及其相互转换——状态模式（二）","date":"2017-05-31T15:43:48.000Z","path":"2017/05/31/design_pattern_29/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"实现对象的复用——享元模式（二）","date":"2017-05-30T12:18:06.000Z","path":"2017/05/30/design_pattern_43/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"建造者模式-Builder Pattern","date":"2017-05-23T08:27:41.000Z","path":"2017/05/23/design_pattern_70/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式综合应用实例","date":"2017-05-21T08:59:30.000Z","path":"2017/05/21/design_pattern_134/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂三兄弟之简单工厂模式（一）","date":"2017-05-13T07:58:50.000Z","path":"2017/05/13/design_pattern_65/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式趣味学习（复习）","date":"2017-05-13T06:18:08.000Z","path":"2017/05/13/design_pattern_135/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"处理多维度变化——桥接模式（四）","date":"2017-05-08T06:36:52.000Z","path":"2017/05/08/design_pattern_26/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"桥接模式-Bridge Pattern","date":"2017-05-05T21:45:15.000Z","path":"2017/05/06/design_pattern_91/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"处理对象的多种状态及其相互转换——状态模式（一）","date":"2017-05-02T14:52:50.000Z","path":"2017/05/02/design_pattern_27/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式之代理模式（四）","date":"2017-04-30T07:15:39.000Z","path":"2017/04/30/design_pattern_129/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"对象间的联动——观察者模式（五）","date":"2017-04-29T12:55:50.000Z","path":"2017/04/29/design_pattern_53/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式之代理模式（三）","date":"2017-04-28T16:07:03.000Z","path":"2017/04/29/design_pattern_127/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"面向对象设计原则之里氏代换原则","date":"2017-04-28T08:10:00.000Z","path":"2017/04/28/design_pattern_162/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"对象的克隆——原型模式（二）","date":"2017-04-22T11:58:09.000Z","path":"2017/04/22/design_pattern_48/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"深入浅出外观模式（二）","date":"2017-04-21T17:29:44.000Z","path":"2017/04/22/design_pattern_98/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"从招式与内功谈起——设计模式概述（一）","date":"2017-04-19T05:00:40.000Z","path":"2017/04/19/design_pattern_8/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式与足球（三）","date":"2017-04-19T02:09:34.000Z","path":"2017/04/19/design_pattern_123/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"扩展系统功能——装饰模式（三）","date":"2017-04-17T21:21:48.000Z","path":"2017/04/18/design_pattern_72/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"模板方法模式深度解析（三）","date":"2017-04-15T09:44:48.000Z","path":"2017/04/15/design_pattern_94/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"备忘录模式-Memento Pattern","date":"2017-04-14T20:46:17.000Z","path":"2017/04/15/design_pattern_33/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"享元模式-Flyweight Pattern","date":"2017-04-13T17:49:31.000Z","path":"2017/04/14/design_pattern_7/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"访问者模式-Visitor Pattern","date":"2017-04-10T18:03:29.000Z","path":"2017/04/11/design_pattern_136/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式之代理模式（二）","date":"2017-04-03T22:09:34.000Z","path":"2017/04/04/design_pattern_128/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"工厂三兄弟之工厂方法模式（一）","date":"2017-04-02T04:21:03.000Z","path":"2017/04/02/design_pattern_56/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"撤销功能的实现——备忘录模式（四）","date":"2017-04-02T02:00:14.000Z","path":"2017/04/02/design_pattern_80/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"深入浅出外观模式（三）","date":"2017-03-31T06:43:38.000Z","path":"2017/03/31/design_pattern_97/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]},{"title":"设计模式与足球（二）","date":"2017-03-31T06:29:44.000Z","path":"2017/03/31/design_pattern_124/","tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://blog4java.com/tags/design-pattern/"}]}]